## 结构型模式
* 结构型设计模式主要总结了一些类或对象组合在一起的经典结构
* 结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，
* 前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象
* 由于组合关系或聚合关系比继承关系耦合度低，满足”合成复用原则“，所以对象结构型模式比类结构型模式具有更大的灵活性
* 结构型模式分为以下 7 中:
* 代理模式
* 适配器模式
* 装饰着模式
* 桥接模式
* 外观模式
* 组合模式
* 享元模式

### 代理模式
* 概述：由于某些原因需要给某个对象提供一个代理以控制对该对象的访问。这时访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介
* java 中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在 java 运行时动态生成。动态代理又有 JDK 代理和 CGLib 代理两种

### 结构
* 代理（Proxy）模式分为三种角色：
* 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法
* 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象（目标对象）
* 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能
* 访问者访问代理对象，代理对象访问目标对象

### JDK 动态代理
* Java 中提供了一个动态代理类 Proxy，Proxy 并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance 方法）来获取代理对象

```java
public class ProxyFactory {
    // 目标对象
    private final TrainStation trainStation = new TrainStation();

    public SellTickets getProxyObject() {
        // 创建代理对象
        /**
         * ClassLoader loader, 类加载器，用于加载代理对象
         * Class<?>[] interfaces, 代理类实现的接口的字节码对象
         * InvocationHandler h 代理对象的回调函数
         */
        return (SellTickets) Proxy.newProxyInstance(
            trainStation.getClass().getClassLoader(),
            trainStation.getClass().getInterfaces(),
            this::call
        );
    }

    private Object call(Object proxy, Method method, Object[] args) throws Exception {
        // proxy 和 sellTickets 是一个
        // method 是调用的那个方法
        // args 是传递的参数
        // 返回值 是方法的返回值
        System.out.println("我是 jdk 动态代理对象");
        Object obj = method.invoke(trainStation, args);
        System.out.println("method -> " + method.getName()); // sell
        return obj;
    }
}
```
执行流程：
* 1、在测试类中通过代理对象调用 sell() 方法
* 2、根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法
* 3、代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法
* 4、invoke 方法里通过 method 反射方式执行了真实对象所属类（TrainStation）中的 sell() 方法

### CGLIB 动态代理
* 如果没有定义 SellTickets 接口，只定义了 TrainStation。很显然 JDK 代理是无法使用了，因为 JDK 动态代理要求必须定义接口，对接口进行代理
* CGLib 是一个功能强大，高性能的代码生成包。它为没有实现接口的类通过代理，为 JDK 的动态代理提供了很好的补充
* CGLib 是第三方提供的包，需要引入
```java
public class ProxyFactory implements MethodInterceptor {
    private final TrainStation trainStation = new TrainStation();

    // 获取代理对象，cglib 实现的方式是 继承
    public TrainStation getProxyObject() {
        // 创建 Enhancer 对象，类似与 JDK 代理中订单 Proxy 类
        Enhancer enhancer = new Enhancer();
        // 设置父类的字节码对象，指定父类
        enhancer.setSuperclass(TrainStation.class);
        // 设置回调函数
        enhancer.setCallback(this);
        // 创建代理对象（TrainStation 的 子类）
        // CGLib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。
        TrainStation proxyObject = (TrainStation) enhancer.create();
        return proxyObject;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("cglib 代理对象执行的放大");
        Object obj = method.invoke(trainStation, objects);
        return obj;
    }
}
```

### 三种代理的对比
* jdk 代理和 CGLib 代理
* 使用 CGLib 实现动态代理，CGLib 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类，CGLib 不能对声明为 final 的类或者方法进行代理，因为 CGLib 原理是动态生成被代理类的子类
* 如果有接口使用 JDK 动态代理，如果没有接口使用 CGLib 东塔代理
* 
* 动态代理和静态代理
* 动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。这样在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转
* 如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题

### 优缺点
* 优点：
* 1、代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
* 2、代理对象可以扩展目标对象的功能
* 3、代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度
* 缺点：增加了系统的复杂度

### 使用场景
* 远程（Remote）代理 RPC
* 防火墙（Firewall）代理
* 保护（Protect or Access） 代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限

### 适配器模式（功能给外部去做，灵活，转换器）
* 定义：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作
* 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应该相对较少

### 结构
* 适配器模式（Adapter）包含以下主要角色：
* 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口
* 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口
* 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者

### 类适配器模式
* 实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件（适配者类）
* 类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用

### 对象适配器模式
* 实现方式：对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中（就是可以传递不同的，如果是继承的话就写死了），该类同时实现当前系统的业务接口
```java
// 目标接口（客户期望的接口）
interface Target {
    void request();
}
 
// 需要适配的类（已存在的类，但接口不符合）
class Adaptee {
    public void specificRequest() {
        System.out.println("适配器类特定的请求方法");
    }
}
 
// 适配器类，将Adaptee的接口转换成Target的接口
class Adapter implements Target {
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    @Override
    public void request() {
        // 这里可以添加一些处理逻辑，将Adaptee的特定请求转换为符合Target接口的请求
        adaptee.specificRequest();
    }
}
 
// 测试适配器模式
public class Main {
    public static void main(String[] args) {
        // 创建一个Adaptee对象
        Adaptee adaptee = new Adaptee();
        
        // 创建一个适配器对象，将adaptee的特定请求适配为Target接口的请求
        Target target = new Adapter(adaptee);
        
        // 客户端通过Target接口调用request方法
        target.request();
    }
}
```
### 应用场景
* 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致
* 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同

### 在Java中，适配器模式有一些常见的用途，包括：
* 将不兼容的接口转换为兼容的接口：适配器模式可以用来将不兼容的接口转换为兼容的接口，使得不同类之间可以更容易地相互通信和协作。
* 实现接口的部分方法：适配器模式可以用来实现接口的部分方法，即只需要实现接口中需要的方法，而不需要实现所有方法。
* 统一接口：适配器模式可以用来统一一组不同类的接口，使它们具有相同的接口，从而可以像处理同一种类一样处理它们。
* 实现回调机制：适配器模式可以用来实现回调机制，即当某个事件发生时，适配器会调用指定的方法，从而实现事件通知和处理。
* 装饰器模式：适配器模式也可以与装饰器模式结合使用，从而可以对已有的对象进行功能增强，而不需要修改其原有的代码。

### 装饰者模式
* 定义：指在不改变现有对象结构的情况下，**动态**的给改对象增加一些职责（即增加其额外功能）的模式

### 结构
* 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象
* 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责
* 抽象装饰（Decorator）角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能
* 具体装饰（Concrete Decorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任（鸡蛋、培根）

### 好处
* 装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。
* 装饰者模式比继承更具有良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任
* 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能

### 使用场景
* 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时
* 不能采用继承的情况主要有两类：
* 1、系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长
* 2、类定义不能继承（如 final 类）
* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
* 当对象的功能要求可以动态的添加，也可以再动态的撤销时

### JDK 中
```java
public class Test2 {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("路径");
        BufferedWriter bw = new BufferedWriter(fw);
        // 写数据
        bw.write("hello");
        bw.close();
    }
}
```
* BufferedWriter 使用装饰者模式对 Writer 子实现类进行了增强，添加了缓冲区，提高了写数据的效率

### 静态代理和装饰者的区别
* 静态代理和装饰者模式的区别：
* 相同点：
* 1、都要实现与目标类相同的业务接口
* 2、在两个类中都要声明目标对象（聚合）
* 3、都可以在不修改目标类的前提下增强目标方法
* 不同点：
* 1、目的不同，装饰者是为了增强目标对象，静态代理是为了保护和隐藏目标对象
* 2、获取目标对象构建的地方不同，装饰者是由外界传递进来，可以通过构造方法传递，静态代理是在代理类内部创建，以此来隐藏目标对象

### 桥接模式
* 定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度

### 结构
* 桥接（Bridge）模式包含以下主要角色：
* 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用
* 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法
* 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用
* 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现
* 
* 需要开发一个跨平台视频播放器，可以在不同操作系统平台（如 Windows，Mac，Linux）上播放多种格式的视频文件，
* 常见的视频格式包括 RMVB、AVI、WMV等，该播放器包含了；两个维度，适合使用桥接模式

### 好处
* 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统

### 使用场景
* 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时
* 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时
* 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系

### 外观模式
* 定义：又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。
* 该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性

### 结构
* 外观（Facade）模式包含以下主要角色：
* 外观（Facade）角色：为多个子系统对外提供一个共同的接口
* 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它
```java
public class SmartAppFacade {
    private final TV tv;

    private final Light light;

    public SmartAppFacade() {
        tv = new TV();
        light = new Light();
    }

    public void say(String msg) {
        if (msg.contains("打开")) {
            on();
        } else if (msg.contains("关闭")) {
            off();
        } else {
            System.out.println("暂无");
        }
    }

    private void on() {
        tv.on();
        light.on();
    }

    private void off() {
        tv.off();
        light.off();
    }
}
```
 
### 好处
* 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类
* 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易
* 缺点：不符合开闭原则，修改很麻烦

### 使用场景
* 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系
* 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问
* 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提供子系统的独立性和可移植性

### 组合模式
* 定义：又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。它创建了对象组的树形结构

### 结构
* 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性（树枝节点和叶子节点都要继承）
* 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构
* 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位

### 组合模式的分类（combination）
* 在使用组合模式时，根据抽象构件类的定义形式，可将组合模式分为透明组合模式和安全组合模式两种方式
* 1、透明组合模式：
* 抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove、getChild 方法，
* 这样做的好处是确保所有的构件类都有相同的接口，透明组合模式也是组合模式的标准形式。
* 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove()
* 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错。
* 2、安全组合模式：
* 在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方。
* 安全模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，
* 因此客户端不能完全针对抽象编程，必须有区别对待叶子构件和容器构件

### 优点
* 组合模式可以清除的定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制
* 客户端可以一致的使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码
* 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”
* 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单

### 使用场景
* 组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结数据的操作

### 享元模式（共享）
* 定义：运用共享技术来有效的支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率

### 结构
* 享元（Flyweight）模式中存在以下两种状态：
* 1、内部状态，既不会随着环境的改变而改变的可共享部分
* 2、外部状态，指随着环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化
* 享元模式主要有以下角色：
* 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）
* 具体享元（Concrete Flyweight）角色：它实现了抽象享元类，称为享元对象，在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象
* 非享元（Unsharable Flyweight）角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建
* 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在的话，则创建一个新的享元对象