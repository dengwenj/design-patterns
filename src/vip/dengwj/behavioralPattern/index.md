### 行为型模式
* 主要是关注交互
* 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法和对象间职责的分配
* 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。
* 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性
* 行为型模式分为：
* 模板方法模式
* 策略模式
* 职责链模式
* 状态模式
* 观察者模式
* 中介者模式
* 迭代器模式
* 访问者模式
* 备忘录模式
* 解释器模式
* 除了模板方法模式和解释器模式是类行为型模式，其他的全部是对象行为型模式 

### 模板方法
* 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤

### 结构
* 模板方法（Template Method）模式包含以下主要角色：
* 抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成
* ---模版方法：定义了算法的骨架，按某种顺序调用其包含的基本方法
* ---基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：
* ------抽象方法：一个抽象方法由抽象类声明、由其具体子类实现
* ------具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承
* ------钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为 isXxx，返回值类型为 boolean 类型
* 具体子类：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤
```java
public abstract class StirFry {
    // 模板方法，执行的流程
    public final void cookProcess() {
        oilDown();
        oilHot();
        pourVegetables(); // 反向控制（由子类去实现，父类调用），反向控制就是模板方法模式的思想
        condiments();
        fry();
    }

    // 下油,流程是固定的，具体方法
    public void oilDown() {
        System.out.println("第一步下油");
    }

    // 热油 流程是固定的
    public void oilHot() {
        System.out.println("第二步热油");
    }

    // 倒蔬菜，具体的东西不知道，抽象方法，子类实现
    public abstract void pourVegetables();

    // 倒调料品，具体的东西不知道，抽象方法
    public abstract void condiments();

    // 翻炒菜
    public void fry() {
        System.out.println("翻炒菜");
    }
}
```

### 优缺点
* 优点：
* 提高代码复用性，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中
* 实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则”
* 反向控制（由子类去实现，父类调用），反向控制就是模板方法模式的思想 
* 缺点：
* 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象
* 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度

### 适用场景
* 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现
* 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制

### 策略模式（多选一的切换）
* 定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。
* 策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理（环境类）

### 结构
* 抽象策略类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口
* 具体策略类：实现了抽象策略定义的接口，提供具体的算法实现或行为
* 环境（Context）类：持有一个策略类的引用，最终给客户端调用

### 优缺点
* 优点：
* 策略类之间可以自由切换，由于策略类都实现同一个接口，所以使它们之间可以自由切换
* 易于扩展，增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则”
* 避免使用多重条件选择语句（if else），充分体现面向对象设计思想
* 缺点：
* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类（可以使用工厂模式）
* 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量

### 使用场景
* 一个系统需要动态的在几种算法中选择一种时，可将每个算法封装到策略类中
* 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句
* 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时
* 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为