### 行为型模式
* 主要是关注交互
* 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法和对象间职责的分配
* 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。
* 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性
* 行为型模式分为：
* 模板方法模式
* 策略模式
* 职责链模式
* 状态模式
* 观察者模式
* 中介者模式
* 迭代器模式
* 访问者模式
* 备忘录模式
* 解释器模式
* 除了模板方法模式和解释器模式是类行为型模式，其他的全部是对象行为型模式 

### 模板方法
* 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤

### 结构
* 模板方法（Template Method）模式包含以下主要角色：
* 抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成
* ---模版方法：定义了算法的骨架，按某种顺序调用其包含的基本方法
* ---基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：
* ------抽象方法：一个抽象方法由抽象类声明、由其具体子类实现
* ------具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承
* ------钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为 isXxx，返回值类型为 boolean 类型
* 具体子类：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤
```java
public abstract class StirFry {
    // 模板方法，执行的流程
    public final void cookProcess() {
        oilDown();
        oilHot();
        pourVegetables();
        condiments();
        fry();
    }

    // 下油,流程是固定的
    public void oilDown() {
        System.out.println("第一步下油");
    }

    // 热油 流程是固定的
    public void oilHot() {
        System.out.println("第二步热油");
    }

    // 倒蔬菜，具体的东西不知道，抽象方法
    public abstract void pourVegetables();

    // 倒调料品，具体的东西不知道，抽象方法
    public abstract void condiments();

    // 翻炒菜
    public void fry() {
        System.out.println("翻炒菜");
    }
}
```

### 优缺点
* 优点：
* 提高代码复用性，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中
* 实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则”
* 缺点：
* 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象
* 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度

### 适用场景
* 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现
* 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制